package main

import (
	"path/filepath"
	"regexp"

	"github.com/go-rod/rod/lib/utils"
	"github.com/ysmood/kit"
)

func main() {
	comment := `// This file is generated by "./lib/proto/generate"`

	schema := getSchema()

	code := comment + kit.S(`

		package proto

		import "reflect"

		// Version of cdp protocol
		const Version = "v{{.major}}.{{.minor}}"
	`, "major", schema.Get("version.major").String(), "minor", schema.Get("version.minor").String())

	init := `
		var types = map[string]reflect.Type{`

	testsCode := comment + `

		package proto_test

		import (
			"testing"

			"github.com/stretchr/testify/assert"
			"github.com/go-rod/rod/lib/proto"
		)
	`

	for _, domain := range parse(schema) {
		for _, definition := range domain.definitions {
			if definition.skip {
				continue
			}

			code += definition.format()
			testsCode += definition.formatTests()

			if definition.originName != "" {
				init += kit.S(`
					"{{.name}}": reflect.TypeOf({{.type}}{}),`,
					"name", definition.domain.name+"."+definition.originName,
					"type", definition.name,
				)
			}
		}
	}

	init += `
		}
	`

	utils.E(kit.OutputFile(filepath.FromSlash("lib/proto/definitions.go"), code+init, nil))
	utils.E(kit.OutputFile(filepath.FromSlash("lib/proto/definitions_test.go"), testsCode, nil))

	kit.MustGoTool("golang.org/x/tools/cmd/goimports")
	kit.MustGoTool("github.com/client9/misspell/cmd/misspell")
	kit.Exec("gofmt", "-s", "-w", "./lib/proto").MustDo()
	kit.Exec("goimports", "-w", "./lib/proto").MustDo()
	kit.Exec("misspell", "-w", "-q", "./lib/proto").MustDo()
}

func (d *definition) comment() string {
	comment := d.description

	if comment == "" {
		comment = "..."
	}

	if d.optional {
		comment = "(optional) " + comment
	}
	if d.experimental {
		comment = "(experimental) " + comment
	}
	if d.deprecated {
		comment = "(deprecated) " + comment
	}

	comment = symbol(d.name) + " " + comment

	return regexp.MustCompile(`(?m)^`).ReplaceAllString(comment, "// ")
}

func (d *definition) format() (code string) {
	switch d.objType {
	case objTypePrimitive:
		code = kit.S(`
		{{.comment}}
		type {{.name}} {{.type}}
		`, "name", d.name, "type", d.typeName, "comment", d.comment())

		if d.enum != nil {
			code += "const ("
			for _, value := range d.enum {
				name := d.name + symbol(value)
				code += kit.S(`
				// {{.name}} enum const
				{{.name}} {{.type}} = "{{.value}}"
				`, "name", name, "type", d.name, "value", value)
			}
			code += ")\n"
		}

	case objTypeStruct:
		code = kit.S(`
		{{.comment}}
		type {{.name}} struct {
		`, "name", d.name, "comment", d.comment())

		for _, prop := range d.props {
			tag := jsonTag(prop.originName, prop.optional)

			code += kit.S(`
			{{.comment}}
			{{.name}} {{.type}} {{.tag}}
			`, "comment", prop.comment(), "name", prop.name, "type", prop.typeName, "tag", tag)
		}

		code += "}\n"

		if d.command {
			method := d.domain.name + "." + d.originName
			if d.returnValue {
				code += kit.S(`
				// MethodName of the command
				func (m {{.name}}) MethodName() string { return "{{.method}}" }

				// Call of the command, sessionID is optional.
				func (m {{.name}}) Call(caller Caller) (*{{.name}}Result, error) {
					var res {{.name}}Result
					return &res, Call(m.MethodName(), m, &res, caller)
				}
				`, "name", d.name, "method", method)
			} else {
				code += kit.S(`
				// MethodName of the command
				func (m {{.name}}) MethodName() string { return "{{.method}}" }

				// Call of the command, sessionID is optional.
				func (m {{.name}}) Call(caller Caller) error {
					return Call(m.MethodName(), m, nil, caller)
				}
				`, "name", d.name, "method", method)
			}
		}

		if d.cdpType == cdpTypeEvents {
			code += kit.S(`
				// MethodName interface
				func (evt {{.name}}) MethodName() string {
					return "{{.event}}"
				}
			`, "name", d.name, "event", d.domain.name+"."+d.originName)
		}
	}

	return
}

func (d *definition) formatTests() (code string) {
	switch d.cdpType {
	case cdpTypeCommands:
		if !d.command {
			return ""
		}

		if d.returnValue {
			return kit.S(`
				func Test{{.name}}(t *testing.T) {
					c := &Client{}
					_, err := proto.{{.name}}{}.Call(&Caller{c})
					assert.Nil(t, err)
				}
				`, "name", d.name)
		}

		return kit.S(`
			func Test{{.name}}(t *testing.T) {
				c := &Client{}
				err := proto.{{.name}}{}.Call(&Caller{c})
				assert.Nil(t, err)
			}
			`, "name", d.name)

	case cdpTypeEvents:
		return kit.S(`
		func Test{{.name}}(t *testing.T) {
			e := proto.{{.name}}{}
			e.MethodName()
		}
		`, "name", d.name)
	}

	return ""
}
